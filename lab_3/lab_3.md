# 网安综合实践 3 & 4

## lab_3

使用 IDA 进行反编译，跟踪代码，观察到在 strcpy 处具有可利用的栈溢出漏洞。由于对 fread 读到的字节长度没有进行合理的检查，当文件大小的低字节在3到8之间时，将产生栈溢出漏洞，栈中的 EIP 可能被改写。

观察调用 strcpy 的函数的存储堆栈，发现调用 strcpy 时距离该函数的 EIP 的距离是20字节。我构造了一个大小为261字节的文件，并将21字节的位置写入输出 “Success” 的函数的地址。

运行pe文件并输入该文件后，成功输出 success。

## lab_4

本次实验需要破解的 PE 文件和上次实验类似。使用 IDA 反编译后，预期出现 strcpy 函数的位置出现了大量用于混淆反编译器的数据。根据 x86 汇编对应的字节码可以推测处，此处也为代码。强制转换为 code 型后可显示出原本的代码。

对 strcpy 函数进行栈溢出利用的原理和 lab_3 相同，注意缓冲区大小和上一次不同。输入 payload 文件后可覆盖返回地址实现任意跳转。

实验要求输出 Success 并获取 flag。进行字符串搜索只能发现字符串 Flag 的位置。依次逆向寻找输出 flag 的函数及调用 flag 的函数，并且在这些函数中观察调用输出字符串的函数。经过搜索后，发现上层函数会调用 strcpy 将 rdata 段中的 “Success!” 复制到某个位置并进行输出。搜索分析后发现，“Success!” 是通过类型转换至 char 型来构造字符串的。

使栈溢出后的返回地址指向输出 “Success!” 的地址，调试运行后成功输出该信息和 flag。
